# 솔루션

## 통과한 코드

```java
import java.util.Collections;
import java.util.PriorityQueue;

class Solution {
	public long solution(int n, int[] works) {
		long answer = 0;
		PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());

		for(int num : works) {
			queue.add(num);
		}

		while(n > 0 && !queue.isEmpty()) {
			int num = queue.poll() - 1;
			if (num == 0) {
				n--;
				continue;
			}
			queue.add(num);
			n--;
		}

		while (!queue.isEmpty()) {
			int num = queue.poll();
			answer += num * num;
		}
		return answer;
	}
}
```

## 풀이 해설

작업 분포가 비슷하게 분포되어 있어야 최소한의 피로도를 얻을 수 있습니다.

우선순위 큐를 사용해서 가장 높은 작업량 부터 1씩 작업하도록 했습니다.


